# To jest format pliku w którym zapisujemy pytania
# oraz 4 odpowiedzi z zaznaczeniem odpowiedniej
# Niech + oznacza prawidłową odpowiedź
# Znak - oznacza niepoprawną
# Quiz powinien być jednokrotnego wyboru.

# Poziom 3

# Proszę dopisywać swoje pytania

#Pytania Angelika

Klasa dziedziczaca nie dziedziczy z klasy bazowej:
+ kazda z powyzszych odpowiedzi
- konstruktorow i destruktora
- przeladowanych operatorow
- funkcji zaprzyjaznionych

const int * wsk to:
+ wskaznik do stalego obiektu
- staly wskaznik
- wskaznik staly do obiketu stalego
- zadna z podanych odpowiedzi

Ktore z ponizszych wyrazen jest nieprawdilowa dyrektywa preprocesora?
+ #ifundef
- #ifdef
- #endif
- #elif

Ktore z ponizszych nie jest standardowym wyjatkiem w C++?
+ std::bad_creat
- std::bad_alloc
- std::bad_cast
- std::bad_typeid

class child: public parent1, public parent2 { } to przyklad:
+ dziedziczenia wielobazowego
- dziedziczenia polimorficznego
- dziedziczenia wirtualnego
- dziedziczenia hierarhicznego

#Paweł D., pytania cpp zestaw 3
Tworzac zmienna ze slowem const mozemy powiedziec, ze:
+ bedzie ona dla nas "read only"
- bedzie ona dla nas "write only"
- bedzie ona dla nas "read-write"
- zadne z podanych

Po wykonaniu kodu i = 1; j = i++; zmienne beda wynosic:
+ i = 2, j = 1
- i = 2, j = 2
- i = 1, j = 1
- i = 1, j = 2

Po wykonaniu kodu i = 1; j = ++i; zmienne beda wynosic:
- i = 2, j = 1
+ i = 2, j = 2
- i = 1, j = 1
- i = 1, j = 2

Tworzac konstruktor kopiujacy musimy szczegolnie uwazac na:
+ klasy zawierajace wskaznik
- inkrementacje
- algorytmy
- biblioteki

Destruktor dla class MojaKlasa to:
- *MojaKlasa();
+ ~MojaKlasa();
- MojaKlasa(destroy);
- &MojaKlasa();

#Kamil Frelichowski, pytania cpp zestaw 3

Mamy następujace wyrażenie: int tel=12345; int *wsk=&tel; int **wsk2=&wsk; std::cout<< *wsk2 zwróci:
- Wartość zmiennej tel
- Adres zmiennej tel
+ Adres wskaźnika wsk
- Undefined behaviour


Mamy literal const char *s= "Tablica charow". std::cout<<s; wyswietli
- Adres wskaźnika s
+ Cały literał
- Pierwszą literę literału
- Błąd,gdyż nie wpisano jawnie znaku \0

Gdy stosujemy typ referencyjny:
+ Referencja jest na stosie a obiekt na stercie
- Referencja i obiekt są na stosie
- Referencja i obiekt są na stercie
- Referencja jest na stercie a obiekt na stosie

Wyrażenie MyFun(int funArg=0) {} dla klasy Myfun ;, to:
- Zwykły konstruktor
- Konstruktor kopiujący
+ Konstruktor domyślny
- Deklaracja funkcji


Lista inicjalizacyjna konstruktora musi byc użyta
- Gdy pole klasy zadeklarowane jest jako stałe 
- Gdy pole klasy jest referencją
- Gdy polem klasy jest obiekt
+ Każde z powyższych
